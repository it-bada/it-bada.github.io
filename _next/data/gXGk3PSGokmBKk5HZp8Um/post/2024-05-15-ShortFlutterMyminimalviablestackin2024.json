{"pageProps":{"post":{"title":"간단 소식 2024년 나의 필수로 사용하는 스택  플러터","description":"","date":"2024-05-15 12:04","slug":"2024-05-15-ShortFlutterMyminimalviablestackin2024","content":"\n\n안녕하세요! 플러터를 사용해 모바일 앱을 만들기로 결정하셨군요. 일단 이 선택은 정말 좋은 선택이에요.\n\n![이미지](/assets/img/2024-05-15-ShortFlutterMyminimalviablestackin2024_0.png)\n\n어쨌든, 이제 시작해봅시다. 모든 프로젝트와 마찬가지로 두 가지 선택지가 있어요. 모든 것을 처음부터 시작하거나 도움이 되는 패키지 스택을 찾는 것이에요.\n\n두 가지 선택 모두 괜찮아요. 하지만 제 의견은 그 사이에 진실을 발견할 수 있다고 생각해요. 이 글은 제 선택(즉, La Mobilery의 선택)을 설명하는 데 목적을 둔 글이에요.\n\n\n\n# 이쪽으로 올 때는 스택이 나오네요\n\n## 상태 관리\n\n리버포드\n\n솔직히 말해서, 플러터에서 상태 관리는 정말 복잡해요. 모두가 각자의 의견을 가지고 있고 어떤 것이 최고인지 왜 다른 것들이 쓰레기인지 말이죠.\n\n\n\nHere is the translation of the text:\n\n내 의견으로는 Riverpod는 훌륭한 도구이지만 학습 곡선이 다소 높습니다. 캐시, 의존성 주입 및 여러 가지 기능을 갖춘 반응형 애플리케이션을 쉽게 구축할 수 있게 해줍니다.\n\n## 데이터 클래스\n\nFreezed\n\nFreezed는 필수적이지는 않지만 데이터 클래스 작성을 위한 코드의 보일러플레이트를 줄여주는 데 도움이 됩니다. 데이터 클래스는 API 모델부터 상태 객체까지 어디에나 존재합니다. 이 코드를 줄여주는 도구를 갖는 것은 좋은 일입니다. 또한 직렬화 메서드를 생성해 줍니다.\n\n\n\n미지를 산타로와 스테이트 관리에 큰 도움이 됩니다. `copyWith`를 사용하여 불변 객체를 가지고 새로운 객체를 생성하는 데 도움이 됩니다.\n\n## 라우팅\n\nGoRouter\n\nGoRouter는 라우팅을 위해 고안된 바와 같이 잘 작동합니다.\n상태 관리처럼 더 많은 대안들이 있지만, 저는 GoRouter를 사용하는 것이 최선의 노력/결과 비율을 제공한다고 생각합니다.\n\n\n\n이제 flutter.dev의 일부가 되어 오랜 시간 동안 여기에 있게 되었습니다.\n\n또한, 학습 곡선이 매우 간단합니다.\n\n## 번역\n\n약어\n\n앱의 90% 시간이 여러 언어로 제공되어야 할 것입니다. Flutter에는 번역을 처리하는 방법이 있지만 다소 귀찮은 일입니다.\n\n\n\n그럼 나는 용어를 발견했어. slang이라는 거 말이야. 쓰기 편하고 빠르고 간단한데도 거의 모든 경우 다 다룰 수 있는 힘이 있어.\n\narb 없어도 json 있어 (만약 arb랑 호환되면)\n\n## 네트워크 요청\n\nDio\n\n\n\n페어하게 말하자면, 아직도 http를 사용하는 이유를 이해하지 못해요.\nDio는 http 옆에 네트워킹을 쉽게 만들어 주는 래퍼에요.\n\ncrud, interceptors, timeout, concurrent, download, form management, 그리고 그 이상의 기능들이 다 들어가 있어서 찾는 기능이 다 있어요.\n\n## Logging\n\nlogger\n\n\n\n이건 디버그 출력이란 걸 사용하지 마세요. 실제 운영 환경에서도 코드가 출력됩니다.\n\n로거를 사용하세요. 로거를 사용해보세요. 조용히 설정할 수 있고, 정보를 읽기 쉽게 출력하며, 간단하고 가벼워요. 로깅에 최적화된 도구로, 여러분의 삶을 바꿔줄 거예요.\n\n# 특별한 노트\n\n한 번 더 말하지만, 이것이 “완벽한” 스택은 아니에요. 완벽한 스택은 없어요. 내가 말할 수 있는 건, 여러분이 알고 있는 도구들이 있는 것이 가장 적합한 스택이란 거예요.\n\n\n\n**시도해보세요** (Provider와 BLoC를 시도해봤는데, 제 경우에는 Riverpod가 제일 적합하더라구요) **그리고 나만의 스택을 구성해보세요.**\n\n게다가, **당신의 선택이 빛나도록 하기 위해 타인에게 어둠을 씌워놓을 필요는 없어요.**\n\n마지막으로, **하나 이상의 앱을 만들 계획이 있다면, 그때는 본격적인 템플릿을 작성해보세요.** 당신의 스택과 함께 템플릿을 만들면 추가적인 시간이 소요될 수 있지만, 두 번째 앱이 시작되자마자 승리를 안고 갈 수 있답니다.\n\n예를 들어, 제가 제 스택을 요기서 만들었어요\n\n\n\n그리고 많은 유료 템플릿(파이어베이스, 레버뉴캣 등이 포함)도 있어요. Apparencekit은 정말 놀라운 거 같아요.\n\n# 다른 사람이 대신 해주는 건 어때요?\n\n모바일 애플리케이션을 만들어주는 회사를 찾고 있다면 망설이지 마세요. LinkedIn에서 연락해주시면 La Mobilery에 대해 이야기 나눌 수 있어요. :)\n\n[Quentin Klein의 LinkedIn](https://www.linkedin.com/in/quentin-klein/)","ogImage":{"url":"/assets/img/2024-05-15-ShortFlutterMyminimalviablestackin2024_0.png"},"coverImage":"/assets/img/2024-05-15-ShortFlutterMyminimalviablestackin2024_0.png","tag":["Tech"],"readingTime":3},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    h2: \"h2\",\n    code: \"code\",\n    strong: \"strong\",\n    a: \"a\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"안녕하세요! 플러터를 사용해 모바일 앱을 만들기로 결정하셨군요. 일단 이 선택은 정말 좋은 선택이에요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-ShortFlutterMyminimalviablestackin2024_0.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"어쨌든, 이제 시작해봅시다. 모든 프로젝트와 마찬가지로 두 가지 선택지가 있어요. 모든 것을 처음부터 시작하거나 도움이 되는 패키지 스택을 찾는 것이에요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"두 가지 선택 모두 괜찮아요. 하지만 제 의견은 그 사이에 진실을 발견할 수 있다고 생각해요. 이 글은 제 선택(즉, La Mobilery의 선택)을 설명하는 데 목적을 둔 글이에요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"이쪽으로 올 때는 스택이 나오네요\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"상태 관리\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"리버포드\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"솔직히 말해서, 플러터에서 상태 관리는 정말 복잡해요. 모두가 각자의 의견을 가지고 있고 어떤 것이 최고인지 왜 다른 것들이 쓰레기인지 말이죠.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here is the translation of the text:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"내 의견으로는 Riverpod는 훌륭한 도구이지만 학습 곡선이 다소 높습니다. 캐시, 의존성 주입 및 여러 가지 기능을 갖춘 반응형 애플리케이션을 쉽게 구축할 수 있게 해줍니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"데이터 클래스\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Freezed\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Freezed는 필수적이지는 않지만 데이터 클래스 작성을 위한 코드의 보일러플레이트를 줄여주는 데 도움이 됩니다. 데이터 클래스는 API 모델부터 상태 객체까지 어디에나 존재합니다. 이 코드를 줄여주는 도구를 갖는 것은 좋은 일입니다. 또한 직렬화 메서드를 생성해 줍니다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"미지를 산타로와 스테이트 관리에 큰 도움이 됩니다. \", _jsx(_components.code, {\n        children: \"copyWith\"\n      }), \"를 사용하여 불변 객체를 가지고 새로운 객체를 생성하는 데 도움이 됩니다.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"라우팅\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"GoRouter\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"GoRouter는 라우팅을 위해 고안된 바와 같이 잘 작동합니다.\\n상태 관리처럼 더 많은 대안들이 있지만, 저는 GoRouter를 사용하는 것이 최선의 노력/결과 비율을 제공한다고 생각합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 flutter.dev의 일부가 되어 오랜 시간 동안 여기에 있게 되었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"또한, 학습 곡선이 매우 간단합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"번역\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"약어\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"앱의 90% 시간이 여러 언어로 제공되어야 할 것입니다. Flutter에는 번역을 처리하는 방법이 있지만 다소 귀찮은 일입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그럼 나는 용어를 발견했어. slang이라는 거 말이야. 쓰기 편하고 빠르고 간단한데도 거의 모든 경우 다 다룰 수 있는 힘이 있어.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"arb 없어도 json 있어 (만약 arb랑 호환되면)\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"네트워크 요청\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Dio\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"페어하게 말하자면, 아직도 http를 사용하는 이유를 이해하지 못해요.\\nDio는 http 옆에 네트워킹을 쉽게 만들어 주는 래퍼에요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"crud, interceptors, timeout, concurrent, download, form management, 그리고 그 이상의 기능들이 다 들어가 있어서 찾는 기능이 다 있어요.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Logging\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"logger\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이건 디버그 출력이란 걸 사용하지 마세요. 실제 운영 환경에서도 코드가 출력됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"로거를 사용하세요. 로거를 사용해보세요. 조용히 설정할 수 있고, 정보를 읽기 쉽게 출력하며, 간단하고 가벼워요. 로깅에 최적화된 도구로, 여러분의 삶을 바꿔줄 거예요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"특별한 노트\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"한 번 더 말하지만, 이것이 “완벽한” 스택은 아니에요. 완벽한 스택은 없어요. 내가 말할 수 있는 건, 여러분이 알고 있는 도구들이 있는 것이 가장 적합한 스택이란 거예요.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"시도해보세요\"\n      }), \" (Provider와 BLoC를 시도해봤는데, 제 경우에는 Riverpod가 제일 적합하더라구요) \", _jsx(_components.strong, {\n        children: \"그리고 나만의 스택을 구성해보세요.\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"게다가, \", _jsx(_components.strong, {\n        children: \"당신의 선택이 빛나도록 하기 위해 타인에게 어둠을 씌워놓을 필요는 없어요.\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"마지막으로, \", _jsx(_components.strong, {\n        children: \"하나 이상의 앱을 만들 계획이 있다면, 그때는 본격적인 템플릿을 작성해보세요.\"\n      }), \" 당신의 스택과 함께 템플릿을 만들면 추가적인 시간이 소요될 수 있지만, 두 번째 앱이 시작되자마자 승리를 안고 갈 수 있답니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어, 제가 제 스택을 요기서 만들었어요\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 많은 유료 템플릿(파이어베이스, 레버뉴캣 등이 포함)도 있어요. Apparencekit은 정말 놀라운 거 같아요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"다른 사람이 대신 해주는 건 어때요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"모바일 애플리케이션을 만들어주는 회사를 찾고 있다면 망설이지 마세요. LinkedIn에서 연락해주시면 La Mobilery에 대해 이야기 나눌 수 있어요. :)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.linkedin.com/in/quentin-klein/\",\n        children: \"Quentin Klein의 LinkedIn\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}