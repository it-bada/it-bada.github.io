{"pageProps":{"post":{"title":"Go언어에서 확장 가능한 워커 풀을 구축하는 방법을 단계별로 안내하는 Concurrent Processing 마스터하기","description":"","date":"2024-05-27 19:52","slug":"2024-05-27-MasteringConcurrentProcessingAStep-by-StepGuidetoBuildingaScalableWorkerPoolinGo","content":"\n**10,000개의 요청을 초당 처리해요!**\n\n🤝 LinkedIn에서 저와 연결해요. 확장 가능한 시스템을 만들어봐요.\n\n이 블로그 포스트에서는 Go를 사용하여 확장 가능한 워커 풀을 구축해볼 거에요. 이 구현은 요청의 대량을 처리하기 위해 워커 풀을 효율적으로 관리하며, 부하에 따라 워커 수를 동적으로 확장합니다. 잠재적인 함정에 대해 논하고, 그것들을 피하는 방법에 대해 알아볼 거에요.\n\n# 개요\n\n<div class=\"content-ad\"></div>\n\n우리는 다음과 같은 기능을 갖춘 작업자 풀을 생성할 것입니다:\n\n- 부하에 따라 작업자 수를 동적으로 조절합니다.\n- 요청을 타임아웃 및 재시도 메커니즘으로 처리합니다.\n- 작업자를 우아하게 종료합니다.\n\n다음은 완전한 코드와 각 부분에 대한 설명 및 문서화가 제공됩니다.\n\n![Mastering Concurrent Processing: A Step-by-Step Guide to Building a Scalable Worker Pool in Go](/assets/img/2024-05-27-MasteringConcurrentProcessingAStep-by-StepGuidetoBuildingaScalableWorkerPoolinGo_0.png)\n\n<div class=\"content-ad\"></div>\n\n# 디스패처\n\n디스패처는 작업자를 관리하고 들어오는 요청을 분배하는 역할을 합니다. 현재 부하에 따라 동적으로 작업자를 추가하거나 제거하며 모든 작업자들을 원활하게 종료합니다.\n\n- AddWorker: 풀에 새 작업자를 추가하고 작업자 수를 증가시킵니다. 작업자는 요청 처리를 시작하기 위해 실행됩니다.\n- RemoveWorker: 최소 필요한 작업자보다 많은 경우 풀에서 작업자를 제거합니다. 작업자는 stopCh 채널을 통해 중지되도록 신호를 보냅니다.\n- ScaleWorkers: 부하에 따라 작업자 수를 동적으로 조정합니다. 부하가 임계값을 초과하고 최대 허용 작업자보다 작은 경우 새 작업자가 추가됩니다. 부하가 임계값 아래이고 최소 필요한 작업자보다 많은 경우 작업자가 제거됩니다.\n- LaunchWorker: 작업자를 시작하고 작업자 수를 증가시킵니다. 일반적으로 초기 작업자 세트에 사용됩니다.\n- MakeRequest: 입력 채널에 요청을 추가합니다. 채널이 가득 찬 경우 요청은 삭제되고 메시지가 기록됩니다.\n- Stop: 모든 작업자를 원활하게 중지합니다. 모든 작업자가 현재 요청 처리를 완료할 때까지 기다립니다. 제한 시간에 도달하면 모든 작업자를 강제로 중지합니다.\n\n# 작업자\n\n<div class=\"content-ad\"></div>\n\n**Worker 구조체는 요청을 처리하는 작업자를 나타냅니다. 각 작업자는 자신만의 고루틴에서 실행되며 채널에서 수신된 들어오는 요청을 청취합니다.**\n\n- **LaunchWorker**: 작업자를 별도의 고루틴으로 실행합니다. 작업자는 입력 채널이 닫히거나 정지 신호를 받을 때까지 들어오는 요청을 처리합니다.\n- **processRequest**: 개별 요청을 처리합니다. 에러가 발생하거나 요청 시간이 초과되었을 경우 최대 지정된 재시도 횟수까지 요청을 다시 시도합니다.\n\n**코드**\n\n```go\n// struct.go\n\npackage workerpool\n\nimport \"time\"\n\n// Request는 작업자에 의해 처리될 요청을 나타냅니다.\ntype Request struct {\n    Handler    RequestHandler\n    Type       int\n    Data       interface{}\n    Timeout    time.Duration // 요청의 제한 시간\n    Retries    int           // 재시도 횟수\n    MaxRetries int           // 최대 재시도 횟수\n}\n\n// RequestHandler는 요청을 처리하는 함수 유형을 정의합니다.\ntype RequestHandler func(interface{}) error\n```\n\n<div class=\"content-ad\"></div>\n\n\n### interface.go\n\n```go\npackage workerpool\n\nimport \"context\"\n\n// WorkerLauncher는 워커를 실행하기 위한 인터페이스입니다.\ntype WorkerLauncher interface {\n LaunchWorker(in chan Request, stopCh chan struct{})\n}\n\n// Dispatcher는 워커 풀을 관리하기 위한 인터페이스입니다.\ntype Dispatcher interface {\n AddWorker(w WorkerLauncher)\n RemoveWorker(minWorkers int)\n LaunchWorker(id int, w WorkerLauncher)\n ScaleWorkers(minWorkers, maxWorkers, loadThreshold int)\n MakeRequest(Request)\n Stop(ctx context.Context)\n}\n```\n\n### worker.go\n\n```go\npackage workerpool\n\nimport (\n \"context\"\n \"fmt\"\n \"sync\"\n \"time\"\n)\n\n// Worker는 요청을 처리하는 워커를 나타냅니다.\ntype Worker struct {\n Id         int\n Wg         *sync.WaitGroup\n ReqHandler map[int]RequestHandler\n}\n\n// LaunchWorker는 워커를 실행하여 들어오는 요청을 처리합니다.\n// 이는 별도의 고루틴에서 실행되며, 입력 채널에서 들어오는 요청을 지속적으로 수신합니다.\n// 워커는 입력 채널이 닫히거나 중지 신호를 받으면 정상적으로 종료됩니다.\nfunc (w *Worker) LaunchWorker(in chan Request, stopCh chan struct{}) {\n go func() {\n  defer w.Wg.Done()\n  for {\n   select {\n   case msg, open := <-in:\n    if !open {\n     // 채널이 닫히면 처리를 중지하고 반환합니다.\n     fmt.Println(\"워커 중지:\", w.Id)\n     return\n    }\n    w.processRequest(msg)\n    time.Sleep(1 * time.Microsecond) // 밀리초 단위의 작은 지연\n   case <-stopCh:\n    fmt.Println(\"워커 중지:\", w.Id)\n    return\n   }\n  }\n }()\n}\n\n// processRequest는 하나의 요청을 처리합니다.\nfunc (w *Worker) processRequest(msg Request) {\n fmt.Printf(\"워커 %d가 요청 처리 중: %v\\n\", w.Id, msg)\n var handler RequestHandler\n var ok bool\n if handler, ok = w.ReqHandler[msg.Type]; !ok {\n  fmt.Println(\"핸들러가 구현되지 않았습니다: 워커ID:\", w.Id)\n } else {\n  if msg.Timeout == 0 {\n   msg.Timeout = time.Duration(10 * time.Millisecond) // 기본 타임아웃\n  }\n  for attempt := 0; attempt <= msg.MaxRetries; attempt++ {\n   var err error\n   done := make(chan struct{})\n   ctx, cancel := context.WithTimeout(context.Background(), msg.Timeout)\n   defer cancel()\n\n   go func() {\n    err = handler(msg.Data)\n    close(done)\n   }()\n\n   select {\n   case <-done:\n    if err == nil {\n     return // 성공적으로 처리\n    }\n    fmt.Printf(\"워커 %d: 요청 처리 중 오류: %v\\n\", w.Id, err)\n   case <-ctx.Done():\n    fmt.Printf(\"워커 %d: 요청 처리 시간 초과: %v\\n\", w.Id, msg.Data)\n   }\n   fmt.Printf(\"워커 %d: 요청 %v에 대한 재시도 %d\\n\", w.Id, attempt, msg.Data)\n  }\n  fmt.Printf(\"워커 %d: %d번 재시도 후 요청 %v 처리 실패\\n\", w.Id, msg.MaxRetries, msg.Data)\n }\n}\n```\n\n### dispatcher.go\n\n```go\npackage workerpool\n\nimport (\n \"context\"\n \"fmt\"\n \"sync\"\n \"time\"\n)\n\n// ReqHandler는 요청 타입별로 매핑된 핸들러 맵입니다.\nvar ReqHandler = map[int]RequestHandler{\n 1: func(data interface{}) error {\n  return nil\n },\n}\n\n// dispatcher는 워커 풀을 관리하고 들어오는 요청을 워커들 사이에 분배하는 역할을 합니다.\ntype dispatcher struct {\n inCh        chan Request\n wg          *sync.WaitGroup\n mu          sync.Mutex\n workerCount int\n stopCh      chan struct{} // 워커에 중지 신호를 보내기 위한 채널\n}\n\n// AddWorker는 새로운 워커를 풀에 추가하고 워커 수를 증가시킵니다.\nfunc (d *dispatcher) AddWorker(w WorkerLauncher) {\n d.mu.Lock()\n defer d.mu.Unlock()\n d.workerCount++\n d.wg.Add(1)\n w.LaunchWorker(d.inCh, d.stopCh)\n}\n\n// RemoveWorker는 워커 수가 minWorkers보다 큰 경우 워커를 풀에서 제거합니다.\nfunc (d *dispatcher) RemoveWorker(minWorkers int) {\n d.mu.Lock()\n defer d.mu.Unlock()\n if d.workerCount > minWorkers {\n  d.workerCount--\n  d.stopCh <- struct{}{} // 워커에 중지 신호 전송\n }\n}\n\n// ScaleWorkers는 현재 부하에 따라 워커 수를 동적으로 조정합니다.\nfunc (d *dispatcher) ScaleWorkers(minWorkers, maxWorkers, loadThreshold int) {\n ticker := time.NewTicker(time.Microsecond)\n defer ticker.Stop()\n\n for range ticker.C {\n  load := len(d.inCh) // 현재 부하는 채널에 대기 중인 요청 수\n  if load > loadThreshold && d.workerCount < maxWorkers {\n   fmt.Println(\"스케일링 트리거\")\n   newWorker := &Worker{\n    Wg:         d.wg,\n    Id:         d.workerCount,\n    ReqHandler: ReqHandler,\n   }\n   d.AddWorker(newWorker)\n  } else if load < 0.75*loadThreshold && d.workerCount > minWorkers {\n   fmt.Println(\"축소 트리거\")\n   d.RemoveWorker(minWorkers)\n  }\n }\n}\n\n// LaunchWorker는 워커를 시작하고 워커 수를 증가시킵니다.\nfunc (d *dispatcher) LaunchWorker(id int, w WorkerLauncher) {\n w.LaunchWorker(d.inCh, d.stopCh) // 중지 채널을 워커에 전달\n d.mu.Lock()\n d.workerCount++\n d.mu.Unlock()\n}\n\n// MakeRequest는 요청을 입력 채널에 추가하거나 채널이 가득 찬 경우 삭제합니다.\nfunc (d *dispatcher) MakeRequest(r Request) {\n select {\n case d.inCh <- r:\n default:\n  // 채널이 가득 찬 경우 처리\n  fmt.Println(\"요청 채널이 가득 찼습니다. 요청 삭제됨.\")\n  // 다른 조치를 취하기 전에 로깅, 요청 버퍼링 또는 다른 조치를 취할 수 있습니다.\n }\n}\n\n// Stop는 모든 워커를 정상적으로 종료하고 처리가 완료될 때까지 기다립니다.\nfunc (d *dispatcher) Stop(ctx context.Context) {\n fmt.Println(\"\\n중지 호출됨\")\n close(d.inCh) // 더 이상 요청을 보내지 않음을 알리기 위해 입력 채널 닫기\n done := make(chan struct{})\n\n go func() {\n  d.wg.Wait() // 모든 워커가 종료될 때까지 대기\n  close(done)\n }()\n\n select {\n case <-done:\n  fmt.Println(\"모든 워커가 정상적으로 중지됨\")\n case <-ctx.Done():\n  fmt.Println(\"시간 초과, 강제 종료\")\n  // 시간 초과 시 모든 워커 강제 종료\n  for i := 0; i < d.workerCount; i++ {\n   d.stopCh <- struct{}{}\n  }\n }\n\n d.wg.Wait()\n}\n\n// NewDispatcher는 버퍼링된 채널과 웨이트 그룹이 있는 새로운 디스패처를 생성합니다.\nfunc NewDispatcher(b int, wg *sync.WaitGroup, maxWorkers int) Dispatcher {\n return &dispatcher{\n  inCh:   make(chan Request, b),\n  wg:     wg,\n  stopCh: make(chan struct{}, maxWorkers), // 블로킹을 방지하기 위한 버퍼링된 채널\n }\n}\n```\n\n### main.go\n\n```go\npackage main\n\nimport (\n \"context\"\n \"fmt\"\n \"runtime\"\n \"sync\"\n \"time\"\n wp \"workerpool/workerpool\"\n)\n\n\n\n<div class=\"content-ad\"></div>\n\n# 메인\n\n주요 기능은 디스패처와 워커를 초기화하고 작업을 보내며, 디스패처를 원활하게 종료합니다.\n\n- GOMAXPROCS를 사용 가능한 CPU 수로 설정합니다.\n- 디스패처를 초기화하고 초기 워커 집합을 시작합니다.\n- 디스패처에 요청을 보냅니다.\n- 타임아웃을 설정하여 디스패처를 원활하게 종료합니다.\n\n우리는 컨텍스트 타임아웃, 버퍼 크기, 최소/최대 워커와 같은 매개변수를 조정하여 초당 요청(RPS)을 최대화하고 애플리케이션 성능을 향상시킬 것입니다.\n\n<div class=\"content-ad\"></div>\n\nStay tuned for practical insights and real-world examples!\n\nIf you've read up till now, I hope you enjoyed this article. If you did, please show your support by giving it a clap, as it helps me stay motivated to assist the community.\n\nFeel free to leave a comment if you noticed any discrepancies in this article or if you have any questions related to the content.\n\nThank you for your time.\n\n<div class=\"content-ad\"></div>\n\n마음에 드시는 사람들과 언제든 연락하세요! LinkedIn에 연결해보는 건 어떠세요? 🤝\n```\n","ogImage":{"url":"/assets/img/2024-05-27-MasteringConcurrentProcessingAStep-by-StepGuidetoBuildingaScalableWorkerPoolinGo_0.png"},"coverImage":"/assets/img/2024-05-27-MasteringConcurrentProcessingAStep-by-StepGuidetoBuildingaScalableWorkerPoolinGo_0.png","tag":["Tech"],"readingTime":8},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><strong>10,000개의 요청을 초당 처리해요!</strong></p>\n<p>🤝 LinkedIn에서 저와 연결해요. 확장 가능한 시스템을 만들어봐요.</p>\n<p>이 블로그 포스트에서는 Go를 사용하여 확장 가능한 워커 풀을 구축해볼 거에요. 이 구현은 요청의 대량을 처리하기 위해 워커 풀을 효율적으로 관리하며, 부하에 따라 워커 수를 동적으로 확장합니다. 잠재적인 함정에 대해 논하고, 그것들을 피하는 방법에 대해 알아볼 거에요.</p>\n<h1>개요</h1>\n<div class=\"content-ad\"></div>\n<p>우리는 다음과 같은 기능을 갖춘 작업자 풀을 생성할 것입니다:</p>\n<ul>\n<li>부하에 따라 작업자 수를 동적으로 조절합니다.</li>\n<li>요청을 타임아웃 및 재시도 메커니즘으로 처리합니다.</li>\n<li>작업자를 우아하게 종료합니다.</li>\n</ul>\n<p>다음은 완전한 코드와 각 부분에 대한 설명 및 문서화가 제공됩니다.</p>\n<p><img src=\"/assets/img/2024-05-27-MasteringConcurrentProcessingAStep-by-StepGuidetoBuildingaScalableWorkerPoolinGo_0.png\" alt=\"Mastering Concurrent Processing: A Step-by-Step Guide to Building a Scalable Worker Pool in Go\"></p>\n<div class=\"content-ad\"></div>\n<h1>디스패처</h1>\n<p>디스패처는 작업자를 관리하고 들어오는 요청을 분배하는 역할을 합니다. 현재 부하에 따라 동적으로 작업자를 추가하거나 제거하며 모든 작업자들을 원활하게 종료합니다.</p>\n<ul>\n<li>AddWorker: 풀에 새 작업자를 추가하고 작업자 수를 증가시킵니다. 작업자는 요청 처리를 시작하기 위해 실행됩니다.</li>\n<li>RemoveWorker: 최소 필요한 작업자보다 많은 경우 풀에서 작업자를 제거합니다. 작업자는 stopCh 채널을 통해 중지되도록 신호를 보냅니다.</li>\n<li>ScaleWorkers: 부하에 따라 작업자 수를 동적으로 조정합니다. 부하가 임계값을 초과하고 최대 허용 작업자보다 작은 경우 새 작업자가 추가됩니다. 부하가 임계값 아래이고 최소 필요한 작업자보다 많은 경우 작업자가 제거됩니다.</li>\n<li>LaunchWorker: 작업자를 시작하고 작업자 수를 증가시킵니다. 일반적으로 초기 작업자 세트에 사용됩니다.</li>\n<li>MakeRequest: 입력 채널에 요청을 추가합니다. 채널이 가득 찬 경우 요청은 삭제되고 메시지가 기록됩니다.</li>\n<li>Stop: 모든 작업자를 원활하게 중지합니다. 모든 작업자가 현재 요청 처리를 완료할 때까지 기다립니다. 제한 시간에 도달하면 모든 작업자를 강제로 중지합니다.</li>\n</ul>\n<h1>작업자</h1>\n<div class=\"content-ad\"></div>\n<p><strong>Worker 구조체는 요청을 처리하는 작업자를 나타냅니다. 각 작업자는 자신만의 고루틴에서 실행되며 채널에서 수신된 들어오는 요청을 청취합니다.</strong></p>\n<ul>\n<li><strong>LaunchWorker</strong>: 작업자를 별도의 고루틴으로 실행합니다. 작업자는 입력 채널이 닫히거나 정지 신호를 받을 때까지 들어오는 요청을 처리합니다.</li>\n<li><strong>processRequest</strong>: 개별 요청을 처리합니다. 에러가 발생하거나 요청 시간이 초과되었을 경우 최대 지정된 재시도 횟수까지 요청을 다시 시도합니다.</li>\n</ul>\n<p><strong>코드</strong></p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-comment\">// struct.go</span>\n\n<span class=\"hljs-keyword\">package</span> workerpool\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\"time\"</span>\n\n<span class=\"hljs-comment\">// Request는 작업자에 의해 처리될 요청을 나타냅니다.</span>\n<span class=\"hljs-keyword\">type</span> Request <span class=\"hljs-keyword\">struct</span> {\n    Handler    RequestHandler\n    Type       <span class=\"hljs-type\">int</span>\n    Data       <span class=\"hljs-keyword\">interface</span>{}\n    Timeout    time.Duration <span class=\"hljs-comment\">// 요청의 제한 시간</span>\n    Retries    <span class=\"hljs-type\">int</span>           <span class=\"hljs-comment\">// 재시도 횟수</span>\n    MaxRetries <span class=\"hljs-type\">int</span>           <span class=\"hljs-comment\">// 최대 재시도 횟수</span>\n}\n\n<span class=\"hljs-comment\">// RequestHandler는 요청을 처리하는 함수 유형을 정의합니다.</span>\n<span class=\"hljs-keyword\">type</span> RequestHandler <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">interface</span>{})</span></span> <span class=\"hljs-type\">error</span>\n</code></pre>\n<div class=\"content-ad\"></div>\n<h3>interface.go</h3>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> workerpool\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\"context\"</span>\n\n<span class=\"hljs-comment\">// WorkerLauncher는 워커를 실행하기 위한 인터페이스입니다.</span>\n<span class=\"hljs-keyword\">type</span> WorkerLauncher <span class=\"hljs-keyword\">interface</span> {\n LaunchWorker(in <span class=\"hljs-keyword\">chan</span> Request, stopCh <span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">struct</span>{})\n}\n\n<span class=\"hljs-comment\">// Dispatcher는 워커 풀을 관리하기 위한 인터페이스입니다.</span>\n<span class=\"hljs-keyword\">type</span> Dispatcher <span class=\"hljs-keyword\">interface</span> {\n AddWorker(w WorkerLauncher)\n RemoveWorker(minWorkers <span class=\"hljs-type\">int</span>)\n LaunchWorker(id <span class=\"hljs-type\">int</span>, w WorkerLauncher)\n ScaleWorkers(minWorkers, maxWorkers, loadThreshold <span class=\"hljs-type\">int</span>)\n MakeRequest(Request)\n Stop(ctx context.Context)\n}\n</code></pre>\n<h3>worker.go</h3>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> workerpool\n\n<span class=\"hljs-keyword\">import</span> (\n <span class=\"hljs-string\">\"context\"</span>\n <span class=\"hljs-string\">\"fmt\"</span>\n <span class=\"hljs-string\">\"sync\"</span>\n <span class=\"hljs-string\">\"time\"</span>\n)\n\n<span class=\"hljs-comment\">// Worker는 요청을 처리하는 워커를 나타냅니다.</span>\n<span class=\"hljs-keyword\">type</span> Worker <span class=\"hljs-keyword\">struct</span> {\n Id         <span class=\"hljs-type\">int</span>\n Wg         *sync.WaitGroup\n ReqHandler <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]RequestHandler\n}\n\n<span class=\"hljs-comment\">// LaunchWorker는 워커를 실행하여 들어오는 요청을 처리합니다.</span>\n<span class=\"hljs-comment\">// 이는 별도의 고루틴에서 실행되며, 입력 채널에서 들어오는 요청을 지속적으로 수신합니다.</span>\n<span class=\"hljs-comment\">// 워커는 입력 채널이 닫히거나 중지 신호를 받으면 정상적으로 종료됩니다.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(w *Worker)</span></span> LaunchWorker(in <span class=\"hljs-keyword\">chan</span> Request, stopCh <span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">struct</span>{}) {\n <span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> {\n  <span class=\"hljs-keyword\">defer</span> w.Wg.Done()\n  <span class=\"hljs-keyword\">for</span> {\n   <span class=\"hljs-keyword\">select</span> {\n   <span class=\"hljs-keyword\">case</span> msg, open := &#x3C;-in:\n    <span class=\"hljs-keyword\">if</span> !open {\n     <span class=\"hljs-comment\">// 채널이 닫히면 처리를 중지하고 반환합니다.</span>\n     fmt.Println(<span class=\"hljs-string\">\"워커 중지:\"</span>, w.Id)\n     <span class=\"hljs-keyword\">return</span>\n    }\n    w.processRequest(msg)\n    time.Sleep(<span class=\"hljs-number\">1</span> * time.Microsecond) <span class=\"hljs-comment\">// 밀리초 단위의 작은 지연</span>\n   <span class=\"hljs-keyword\">case</span> &#x3C;-stopCh:\n    fmt.Println(<span class=\"hljs-string\">\"워커 중지:\"</span>, w.Id)\n    <span class=\"hljs-keyword\">return</span>\n   }\n  }\n }()\n}\n\n<span class=\"hljs-comment\">// processRequest는 하나의 요청을 처리합니다.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(w *Worker)</span></span> processRequest(msg Request) {\n fmt.Printf(<span class=\"hljs-string\">\"워커 %d가 요청 처리 중: %v\\n\"</span>, w.Id, msg)\n <span class=\"hljs-keyword\">var</span> handler RequestHandler\n <span class=\"hljs-keyword\">var</span> ok <span class=\"hljs-type\">bool</span>\n <span class=\"hljs-keyword\">if</span> handler, ok = w.ReqHandler[msg.Type]; !ok {\n  fmt.Println(<span class=\"hljs-string\">\"핸들러가 구현되지 않았습니다: 워커ID:\"</span>, w.Id)\n } <span class=\"hljs-keyword\">else</span> {\n  <span class=\"hljs-keyword\">if</span> msg.Timeout == <span class=\"hljs-number\">0</span> {\n   msg.Timeout = time.Duration(<span class=\"hljs-number\">10</span> * time.Millisecond) <span class=\"hljs-comment\">// 기본 타임아웃</span>\n  }\n  <span class=\"hljs-keyword\">for</span> attempt := <span class=\"hljs-number\">0</span>; attempt &#x3C;= msg.MaxRetries; attempt++ {\n   <span class=\"hljs-keyword\">var</span> err <span class=\"hljs-type\">error</span>\n   done := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">struct</span>{})\n   ctx, cancel := context.WithTimeout(context.Background(), msg.Timeout)\n   <span class=\"hljs-keyword\">defer</span> cancel()\n\n   <span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> {\n    err = handler(msg.Data)\n    <span class=\"hljs-built_in\">close</span>(done)\n   }()\n\n   <span class=\"hljs-keyword\">select</span> {\n   <span class=\"hljs-keyword\">case</span> &#x3C;-done:\n    <span class=\"hljs-keyword\">if</span> err == <span class=\"hljs-literal\">nil</span> {\n     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">// 성공적으로 처리</span>\n    }\n    fmt.Printf(<span class=\"hljs-string\">\"워커 %d: 요청 처리 중 오류: %v\\n\"</span>, w.Id, err)\n   <span class=\"hljs-keyword\">case</span> &#x3C;-ctx.Done():\n    fmt.Printf(<span class=\"hljs-string\">\"워커 %d: 요청 처리 시간 초과: %v\\n\"</span>, w.Id, msg.Data)\n   }\n   fmt.Printf(<span class=\"hljs-string\">\"워커 %d: 요청 %v에 대한 재시도 %d\\n\"</span>, w.Id, attempt, msg.Data)\n  }\n  fmt.Printf(<span class=\"hljs-string\">\"워커 %d: %d번 재시도 후 요청 %v 처리 실패\\n\"</span>, w.Id, msg.MaxRetries, msg.Data)\n }\n}\n</code></pre>\n<h3>dispatcher.go</h3>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> workerpool\n\n<span class=\"hljs-keyword\">import</span> (\n <span class=\"hljs-string\">\"context\"</span>\n <span class=\"hljs-string\">\"fmt\"</span>\n <span class=\"hljs-string\">\"sync\"</span>\n <span class=\"hljs-string\">\"time\"</span>\n)\n\n<span class=\"hljs-comment\">// ReqHandler는 요청 타입별로 매핑된 핸들러 맵입니다.</span>\n<span class=\"hljs-keyword\">var</span> ReqHandler = <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]RequestHandler{\n <span class=\"hljs-number\">1</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(data <span class=\"hljs-keyword\">interface</span>{})</span></span> <span class=\"hljs-type\">error</span> {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n },\n}\n\n<span class=\"hljs-comment\">// dispatcher는 워커 풀을 관리하고 들어오는 요청을 워커들 사이에 분배하는 역할을 합니다.</span>\n<span class=\"hljs-keyword\">type</span> dispatcher <span class=\"hljs-keyword\">struct</span> {\n inCh        <span class=\"hljs-keyword\">chan</span> Request\n wg          *sync.WaitGroup\n mu          sync.Mutex\n workerCount <span class=\"hljs-type\">int</span>\n stopCh      <span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">struct</span>{} <span class=\"hljs-comment\">// 워커에 중지 신호를 보내기 위한 채널</span>\n}\n\n<span class=\"hljs-comment\">// AddWorker는 새로운 워커를 풀에 추가하고 워커 수를 증가시킵니다.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(d *dispatcher)</span></span> AddWorker(w WorkerLauncher) {\n d.mu.Lock()\n <span class=\"hljs-keyword\">defer</span> d.mu.Unlock()\n d.workerCount++\n d.wg.Add(<span class=\"hljs-number\">1</span>)\n w.LaunchWorker(d.inCh, d.stopCh)\n}\n\n<span class=\"hljs-comment\">// RemoveWorker는 워커 수가 minWorkers보다 큰 경우 워커를 풀에서 제거합니다.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(d *dispatcher)</span></span> RemoveWorker(minWorkers <span class=\"hljs-type\">int</span>) {\n d.mu.Lock()\n <span class=\"hljs-keyword\">defer</span> d.mu.Unlock()\n <span class=\"hljs-keyword\">if</span> d.workerCount > minWorkers {\n  d.workerCount--\n  d.stopCh &#x3C;- <span class=\"hljs-keyword\">struct</span>{}{} <span class=\"hljs-comment\">// 워커에 중지 신호 전송</span>\n }\n}\n\n<span class=\"hljs-comment\">// ScaleWorkers는 현재 부하에 따라 워커 수를 동적으로 조정합니다.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(d *dispatcher)</span></span> ScaleWorkers(minWorkers, maxWorkers, loadThreshold <span class=\"hljs-type\">int</span>) {\n ticker := time.NewTicker(time.Microsecond)\n <span class=\"hljs-keyword\">defer</span> ticker.Stop()\n\n <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">range</span> ticker.C {\n  load := <span class=\"hljs-built_in\">len</span>(d.inCh) <span class=\"hljs-comment\">// 현재 부하는 채널에 대기 중인 요청 수</span>\n  <span class=\"hljs-keyword\">if</span> load > loadThreshold &#x26;&#x26; d.workerCount &#x3C; maxWorkers {\n   fmt.Println(<span class=\"hljs-string\">\"스케일링 트리거\"</span>)\n   newWorker := &#x26;Worker{\n    Wg:         d.wg,\n    Id:         d.workerCount,\n    ReqHandler: ReqHandler,\n   }\n   d.AddWorker(newWorker)\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> load &#x3C; <span class=\"hljs-number\">0.75</span>*loadThreshold &#x26;&#x26; d.workerCount > minWorkers {\n   fmt.Println(<span class=\"hljs-string\">\"축소 트리거\"</span>)\n   d.RemoveWorker(minWorkers)\n  }\n }\n}\n\n<span class=\"hljs-comment\">// LaunchWorker는 워커를 시작하고 워커 수를 증가시킵니다.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(d *dispatcher)</span></span> LaunchWorker(id <span class=\"hljs-type\">int</span>, w WorkerLauncher) {\n w.LaunchWorker(d.inCh, d.stopCh) <span class=\"hljs-comment\">// 중지 채널을 워커에 전달</span>\n d.mu.Lock()\n d.workerCount++\n d.mu.Unlock()\n}\n\n<span class=\"hljs-comment\">// MakeRequest는 요청을 입력 채널에 추가하거나 채널이 가득 찬 경우 삭제합니다.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(d *dispatcher)</span></span> MakeRequest(r Request) {\n <span class=\"hljs-keyword\">select</span> {\n <span class=\"hljs-keyword\">case</span> d.inCh &#x3C;- r:\n <span class=\"hljs-keyword\">default</span>:\n  <span class=\"hljs-comment\">// 채널이 가득 찬 경우 처리</span>\n  fmt.Println(<span class=\"hljs-string\">\"요청 채널이 가득 찼습니다. 요청 삭제됨.\"</span>)\n  <span class=\"hljs-comment\">// 다른 조치를 취하기 전에 로깅, 요청 버퍼링 또는 다른 조치를 취할 수 있습니다.</span>\n }\n}\n\n<span class=\"hljs-comment\">// Stop는 모든 워커를 정상적으로 종료하고 처리가 완료될 때까지 기다립니다.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(d *dispatcher)</span></span> Stop(ctx context.Context) {\n fmt.Println(<span class=\"hljs-string\">\"\\n중지 호출됨\"</span>)\n <span class=\"hljs-built_in\">close</span>(d.inCh) <span class=\"hljs-comment\">// 더 이상 요청을 보내지 않음을 알리기 위해 입력 채널 닫기</span>\n done := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">struct</span>{})\n\n <span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> {\n  d.wg.Wait() <span class=\"hljs-comment\">// 모든 워커가 종료될 때까지 대기</span>\n  <span class=\"hljs-built_in\">close</span>(done)\n }()\n\n <span class=\"hljs-keyword\">select</span> {\n <span class=\"hljs-keyword\">case</span> &#x3C;-done:\n  fmt.Println(<span class=\"hljs-string\">\"모든 워커가 정상적으로 중지됨\"</span>)\n <span class=\"hljs-keyword\">case</span> &#x3C;-ctx.Done():\n  fmt.Println(<span class=\"hljs-string\">\"시간 초과, 강제 종료\"</span>)\n  <span class=\"hljs-comment\">// 시간 초과 시 모든 워커 강제 종료</span>\n  <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &#x3C; d.workerCount; i++ {\n   d.stopCh &#x3C;- <span class=\"hljs-keyword\">struct</span>{}{}\n  }\n }\n\n d.wg.Wait()\n}\n\n<span class=\"hljs-comment\">// NewDispatcher는 버퍼링된 채널과 웨이트 그룹이 있는 새로운 디스패처를 생성합니다.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewDispatcher</span><span class=\"hljs-params\">(b <span class=\"hljs-type\">int</span>, wg *sync.WaitGroup, maxWorkers <span class=\"hljs-type\">int</span>)</span></span> Dispatcher {\n <span class=\"hljs-keyword\">return</span> &#x26;dispatcher{\n  inCh:   <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> Request, b),\n  wg:     wg,\n  stopCh: <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">struct</span>{}, maxWorkers), <span class=\"hljs-comment\">// 블로킹을 방지하기 위한 버퍼링된 채널</span>\n }\n}\n</code></pre>\n<h3>main.go</h3>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n <span class=\"hljs-string\">\"context\"</span>\n <span class=\"hljs-string\">\"fmt\"</span>\n <span class=\"hljs-string\">\"runtime\"</span>\n <span class=\"hljs-string\">\"sync\"</span>\n <span class=\"hljs-string\">\"time\"</span>\n wp <span class=\"hljs-string\">\"workerpool/workerpool\"</span>\n)\n\n\n\n&#x3C;div class=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\n# 메인\n\n주요 기능은 디스패처와 워커를 초기화하고 작업을 보내며, 디스패처를 원활하게 종료합니다.\n\n- GOMAXPROCS를 사용 가능한 CPU 수로 설정합니다.\n- 디스패처를 초기화하고 초기 워커 집합을 시작합니다.\n- 디스패처에 요청을 보냅니다.\n- 타임아웃을 설정하여 디스패처를 원활하게 종료합니다.\n\n우리는 컨텍스트 타임아웃, 버퍼 크기, 최소/최대 워커와 같은 매개변수를 조정하여 초당 요청(RPS)을 최대화하고 애플리케이션 성능을 향상시킬 것입니다.\n\n&#x3C;div class=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\nStay tuned <span class=\"hljs-keyword\">for</span> practical insights and <span class=\"hljs-built_in\">real</span>-world examples!\n\nIf you<span class=\"hljs-string\">'ve read up till now, I hope you enjoyed this article. If you did, please show your support by giving it a clap, as it helps me stay motivated to assist the community.\n\nFeel free to leave a comment if you noticed any discrepancies in this article or if you have any questions related to the content.\n\nThank you for your time.\n\n&#x3C;div class=\"content-ad\">&#x3C;/div>\n\n마음에 드시는 사람들과 언제든 연락하세요! LinkedIn에 연결해보는 건 어떠세요? 🤝\n</span></code></pre>\n</body>\n</html>\n"},"__N_SSG":true}